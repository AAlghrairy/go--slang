import { ArrayLiteralExpression, ArrowFunction, FunctionDeclaration, FunctionExpression, Node, NumericLiteral, ObjectLiteralExpression, StringLiteral, ts, TypeNode } from 'ts-morph';
/**
 * Wraps an expression in a `as const` declaration. E.g., `{foo: 1}` -> `{foo: 1} as const`
 */
export declare function wrapNodeInAsConstDeclaration(node: Node<ts.Expression>): void;
/**
 * Returns the nearest enclosing function-like node. (E.g., a function declaration or arrow function, etc.)
 */
export declare function getEnclosingFunction(node: Node): FunctionDeclaration | FunctionExpression | ArrowFunction | undefined;
/**
 * Replace `typeNode` with an array of the same type.
 *
 * **Warning**: this function invalidates previous references to the type.
 * (E.g., if you obtained a reference via `typeDeclaration.getType()`, you must do so again,
 * because the old reference will be stale.)
 */
export declare function makeTypeAnArray(typeNode: TypeNode): Node<ts.Node>;
/**
 * Replace `typeNode` with an union type including undefined.
 *
 * **Warning**: this function invalidates previous references to the type.
 * (E.g., if you obtained a reference via `typeDeclaration.getType()`, you must do so again,
 * because the old reference will be stale.)
 */
export declare function unionWithNull(typeNode: TypeNode): Node<ts.Node>;
/**
 * Determine if `node` is a literal. E.g. `[5,6]` or `{a: 7}` or `"foo"`.
 */
export declare function isLiteral(node: Node | undefined): node is ObjectLiteralExpression | StringLiteral | ArrayLiteralExpression | NumericLiteral;
/**
 * Returns a union type with all duplicate entries removed.
 */
export declare function formatUnionType(subtypes: string[]): string;
/**
 * Safely "stringify" a string. This works in both Nodejs and
 * in the browser. All non-ascii characters are converted to
 * unicode escape sequences.
 */
export declare function escapedString(str: string): string;
