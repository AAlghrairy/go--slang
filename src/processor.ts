/**
 * Exports a "process" function that can be used to process the AST generated by the parser.
 * Processing involves:
 * 1. Adding scope to each node of the AST. (to serve as an in-built symbol table with lexcial scoping)
 */

import {
  Block,
  Declaration,
  FunctionDeclaration,
  FunctionDefinition,
  Initialization,
  Root,
  Scope,
  ScopedNode,
  Variable,
  VariableDeclaration,
} from "cnodes";
import { ProcessingError } from "errors";

function createNewScope() {
  return {
    functions: {},
    variables: {},
  };
}

export default function process(ast: Root, sourceCode: string) {
  createScopesAndVariables(ast, sourceCode);
  return ast;
}

function createScopesAndVariables(ast: Root, sourceCode: string) {
  const scopeStack: Scope[] = []; // stores a stack of scopes

  /**
   * Checks for redeclaration of a variable, throw ProcessingError if redeclaration has occured.
   * @param name name of variable
   * @param sourceCode
   * @param node AST node that the variable is at
   */
  function checkForRedeclaration(
    node: Declaration | Initialization | FunctionDefinition
  ) {
    if (node.data.name in node.scope.variables || node.data.name in node.scope.functions) {
      // check for redeclaration
      throw new ProcessingError(
        `'${node.data.name}' redeclared`,
        sourceCode,
        node.position
      );
    }
  }

  /**
   * Gets the function prameters of a function as array of Variable.
   * Throws a redeclaration error if duplicate param names encountered.
   * @param node
   */
  function getFunctionParams(
    node: FunctionDeclaration | FunctionDefinition
  ): Variable[] {
    const s: Record<string, boolean> = {};
    return node.data.parameters.map((param) => {
      if (param.data.name in s) {
        throw new ProcessingError(
          `Redeclaration of function parameter ${param.data.name}`,
          sourceCode,
          node.position
        );
      }
      s[param.data.name] = true;
      return {
        name: param.data.name,
        type: param.data.variableType,
      };
    });
  }

  if (!ast) {
    throw new ProcessingError("No Root AST node found", sourceCode, {
      start: { line: 0, column: 0, offset: 0 },
      end: { line: 0, column: 0, offset: 0 },
    });
  }

  // the visitor function for visiting nodes
  function visit(node: ScopedNode) {
    if (node.type === "Root") {
      const n = node as Root;
      node.scope = createNewScope();
      scopeStack.push(node.scope);
      for (const child of n.children) {
        visit(child);
      }
    } else if (node.type === "Block") {
      const n = node as Block;
      n.scope = createNewScope();
      n.parentScope = scopeStack[scopeStack.length - 1];
      scopeStack.push(n.scope);
      for (const child of n.children) {
        visit(child);
      }
      scopeStack.pop();
    } else if (
      node.type === "VariableDeclaration" ||
      node.type === "Initialization"
    ) {
      const n = node as VariableDeclaration;
      n.scope = scopeStack[scopeStack.length - 1];
      checkForRedeclaration(n);
      // add this new variable to the scope
      n.scope.variables[n.data.name] = {
        type: n.data.variableType,
        name: n.data.name,
      };
    } else if (node.type === "FunctionDeclaration") {
      const n = node as FunctionDeclaration;
      n.scope = scopeStack[scopeStack.length - 1];
      checkForRedeclaration(n);
      n.scope.functions[n.data.name] = {
        returnType: n.data.returnType,
        name: n.data.name,
        parameters: getFunctionParams(n),
      };
    } else if (node.type === "FunctionDefinition") {
      const n = node as FunctionDefinition;
      n.scope = scopeStack[scopeStack.length - 1];
      checkForRedeclaration(n);
      const params = getFunctionParams(n);
      n.scope.functions[n.data.name] = {
        returnType: n.data.returnType,
        name: n.data.name,
        parameters: params,
      };
      // add a new scope just for function variables TODO: see if this is a good idea later
      n.parentScope = n.scope;
      n.scope = createNewScope();
      scopeStack.push(n.scope);
      for (const param of params) {
        n.scope.variables[param.name] = { ...param };
      }
      // traverse function body nodes
      visit(n.data.body);
      scopeStack.pop();
    }
  }

  visit(ast);
}
