import type { ast } from 'peggy';
import { Project } from 'ts-morph';
type Grammar = ast.Grammar;
type Expression = ast.Expression;
type ActionExpression = ast.Action;
type Named = ast.Named;
type TypeExtractorOptions = {
    /**
     * Autogenerated types may be marked with the `readonly` keyword, as this
     * keyword is sometimes inserted during type generation. Setting this flag
     * causes the `readonly` keyword to be removed after processing.
     */
    removeReadonlyKeyword?: boolean;
    /**
     * Whether to force type names to be camel case. If `false`,
     * type names will be named the same as the rules from the Peggy grammar.
     */
    camelCaseTypeNames?: boolean;
};
/**
 * Object that handles type creation and extraction from
 * a Peggy Grammar. By default, type names are created from
 * Peggy grammar rules and converted to CamelCase.
 *
 * Example usage
 * ```
 * const typeExtractor = new TypeExtractor(peggyGrammar);
 * const fullTypescriptTypes = typeExtractor.getTypes();
 * const specificTypeForGrammarRule = typeExtractor.typeCache.get("RuleName");
 * ```
 */
export declare class TypeExtractor {
    #private;
    grammar: Grammar;
    sourceHeader: string;
    project: Project;
    nameMap: Map<string, string>;
    typeCache: Map<string, string>;
    options: TypeExtractorOptions;
    formatter: (str: string) => string;
    constructor(grammar: Grammar | string, options?: TypeExtractorOptions);
    /**
     * Create typescript source code for the types in the grammar.
     *
     * @param typeOverrides - An object whose keys are rule names and values are types. These will override any computed type. They can be full typescript expressions (e.g. `Foo | Bar`).
     */
    getTypes(options?: {
        typeOverrides?: Record<string, string>;
    }): string;
    /**
     * Returns the best-guess type for an Expression node in the grammar.
     *
     * For example, a rule with definition `Foo = [a-z]` would be type `string`.
     * A rule with definition `Foo = Bar / Baz` would be type `Bar | Baz`.
     */
    getTypeForExpression(expr: Expression | Named): string;
    _getTypeForAction(action: ActionExpression): string;
}
export {};
