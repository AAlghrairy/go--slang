var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _renameGrammarRules, renameGrammarRules_fn, _initNameMap, initNameMap_fn, _initSourceHeader, initSourceHeader_fn;
import { ts, Project, ScriptTarget } from "ts-morph";
import * as peggy from "peggy";
import * as prettierPluginTypescript from "prettier/parser-typescript";
import prettier from "prettier/standalone";
function wrapNodeInAsConstDeclaration(node) {
  node.transform(
    (t) => t.factory.createAsExpression(
      node.compilerNode,
      t.factory.createTypeReferenceNode(t.factory.createIdentifier("const"))
    )
  );
}
function getEnclosingFunction(node) {
  var _a;
  return (_a = node.getParentWhile((n) => !isFunctionLike(n))) == null ? void 0 : _a.getParent();
}
function isFunctionLike(node) {
  return node.isKind(ts.SyntaxKind.FunctionDeclaration) || node.isKind(ts.SyntaxKind.FunctionExpression) || node.isKind(ts.SyntaxKind.ArrowFunction);
}
function isLiteral(node) {
  if (!node) {
    return false;
  }
  return node.isKind(ts.SyntaxKind.ObjectLiteralExpression) || node.isKind(ts.SyntaxKind.StringLiteral) || node.isKind(ts.SyntaxKind.ArrayLiteralExpression) || node.isKind(ts.SyntaxKind.NumericLiteral);
}
function formatUnionType(subtypes) {
  const uniqueTypes = Array.from(new Set(subtypes));
  return uniqueTypes.join(" | ");
}
function escapedString(str) {
  return JSON.stringify(str).replace(/[\u007F-\uFFFF]/g, function(chr) {
    return "\\u" + ("0000" + chr.charCodeAt(0).toString(16)).slice(-4);
  });
}
function getUniqueName(nameProposal, nameMap, excludeReservedWords) {
  const origProposal = nameProposal;
  let i = 1;
  while (nameMap.has(nameProposal) || excludeReservedWords && RESERVED_WORDS.has(nameProposal)) {
    nameProposal = `${origProposal}_${i}`;
    i++;
  }
  return nameProposal;
}
function isKeyword(name) {
  return RESERVED_WORDS.has(name);
}
const RESERVED_WORDS = /* @__PURE__ */ new Set([
  // Javascript
  "abstract",
  "boolean",
  "break",
  "byte",
  "case",
  "catch",
  "char",
  "class",
  "continue",
  "const",
  "debugger",
  "default",
  "delete",
  "do",
  "double",
  "else",
  "enum",
  "export",
  "extends",
  "false",
  "final",
  "finally",
  "float",
  "for",
  "function",
  "goto",
  "if",
  "implements",
  "import",
  "in",
  "instanceof",
  "int",
  "interface",
  "long",
  "native",
  "new",
  "null",
  "package",
  "private",
  "protected",
  "public",
  "return",
  "short",
  "static",
  "super",
  "switch",
  "synchronized",
  "this",
  "throw",
  "throws",
  "transient",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "alert",
  "arguments",
  "Array",
  "blur",
  "Boolean",
  "callee",
  "caller",
  "captureEvents",
  "clearInterval",
  "clearTimeout",
  "close",
  "closed",
  "confirm",
  "constructor",
  "Date",
  "defaultStatus",
  "document",
  "escape",
  "eval",
  "find",
  "focus",
  "frames",
  "Function",
  "history",
  "home",
  "Infinity",
  "innerHeight",
  "innerWidth",
  "isFinite",
  "isNaN",
  "java",
  "length",
  "location",
  "locationbar",
  "Math",
  "menubar",
  "moveBy",
  "name",
  "NaN",
  "netscape",
  "Number",
  "Object",
  "open",
  "opener",
  "outerHeight",
  "outerWidth",
  "Packages",
  "pageXOffset",
  "pageYOffset",
  "parent",
  "parseFloat",
  "parseInt",
  "personalbar",
  "print",
  "prompt",
  "prototype",
  "RegExp",
  "releaseEvents",
  "resizeBy",
  "resizeTo",
  "routeEvent",
  "scroll",
  "scrollbars",
  "scrollBy",
  "scrollTo",
  "self",
  "setInterval",
  "setTimeout",
  "status",
  "statusbar",
  "stop",
  "String",
  "toolbar",
  "top",
  "toString",
  "unescape",
  "unwatch",
  "valueOf",
  "watch",
  "window",
  // Typescript
  "as",
  "implements",
  "interface",
  "let",
  "package",
  "private",
  "protected",
  "public",
  "static",
  "yield",
  "any",
  "boolean",
  "constructor",
  "declare",
  "get",
  "module",
  "require",
  "number",
  "set",
  "string",
  "symbol",
  "type",
  "from",
  "of",
  "Awaited",
  "Partial",
  "Required",
  "Readonly",
  "Record",
  "Pick",
  "Omit",
  "Exclude",
  "Extract",
  "NonNullable",
  "Parameters",
  "ConstructorParameters",
  "ReturnType",
  "InstanceType",
  "ThisParameterType",
  "OmitThisParameter",
  "ThisType",
  "Intrinsic String Manipulation Types",
  "Uppercase",
  "Lowercase",
  "Capitalize",
  "Uncapitalize",
  "number",
  "string",
  "boolean",
  "object",
  "enum",
  "void",
  "null",
  "undefined",
  "any",
  "never",
  "Array",
  "tuple",
  "Number",
  "String",
  "Boolean",
  "Object",
  "Function"
]);
function pruneCircularReferences(file) {
  let diagnostics = file.getPreEmitDiagnostics().filter((d) => d.getCode() === 2456);
  if (diagnostics.length === 0) {
    return;
  }
  const maxLoops = diagnostics.length / 2;
  for (let i = 0; i < maxLoops; i++) {
    if (i > 0) {
      diagnostics = file.getPreEmitDiagnostics().filter((d) => d.getCode() === 2456);
    }
    if (diagnostics.length === 0) {
      return;
    }
    const info = diagnostics.map((d) => getInfoFromDiagnostic(d, file));
    const eliminateRefName = info[0].name;
    for (const typeInfo of info.slice(1)) {
      for (const typeRef of typeInfo.unionedIdentifiers) {
        if (typeRef.refName === eliminateRefName) {
          const node = typeRef.node;
          node.replaceWithText("void");
        }
      }
    }
  }
  diagnostics = file.getPreEmitDiagnostics().filter((d) => d.getCode() === 2456);
  if (diagnostics.length > 0) {
    console.warn(
      `Tried, but failed to eliminate circular references in generated types. The following errors remain: ${diagnostics.map((d) => d.getMessageText()).join("; ")}`
    );
  }
}
function getInfoFromDiagnostic(d, file) {
  const start = d.getStart();
  if (start == null) {
    throw new Error(`Diagnostic has no start position`);
  }
  const node = file.getDescendantAtPos(start);
  if (node == null) {
    throw new Error(`Cannot find node at position ${start}`);
  }
  const parent = node.getParentOrThrow();
  if (!parent.isKind(ts.SyntaxKind.TypeAliasDeclaration)) {
    throw new Error(
      `Parent of node is of kind "${parent.getKindName()}", not "TypeAliasDeclaration"`
    );
  }
  const typeBodyNode = parent.getTypeNodeOrThrow();
  if (!typeBodyNode.isKind(ts.SyntaxKind.UnionType)) {
    throw new Error(
      `Can only remove recursive type definitions on union types not "${typeBodyNode.getKindName()}"`
    );
  }
  return { name: node.getText(), unionedIdentifiers: listUnionedIdentifiers(typeBodyNode) };
}
function listUnionedIdentifiers(node) {
  if (node.isKind(ts.SyntaxKind.UnionType)) {
    return node.getTypeNodes().flatMap((n) => listUnionedIdentifiers(n));
  }
  if (node.isKind(ts.SyntaxKind.ParenthesizedType)) {
    return listUnionedIdentifiers(node.getTypeNode());
  }
  if (node.isKind(ts.SyntaxKind.TypeReference)) {
    return [{ refName: node.getText(), node }];
  }
  return [];
}
function snakeToCamel(str) {
  if (str.startsWith("_")) {
    return "_" + snakeToCamel(str.slice(1));
  }
  return str.split("_").map((s) => capitalize(s)).join("");
}
function capitalize(str) {
  if (str.length === 0) {
    return str;
  }
  if (str.charAt(0) !== str.charAt(0).toUpperCase()) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  return str;
}
const TYPES_HEADER = `// These types were autogenerated by ts-pegjs
`;
const SOURCE_HEADER = `
// Peggy has built-in globals that we want to be always declared.
declare const options: {};
declare function text(): string;
declare function location(): { source: string | undefined; start: { offset: number; line: number; column: number }; end: { offset: number; line: number; column: number } };
declare function offset(): { offset: number; line: number; column: number };
declare function range(): {source: string | undefined, start: number, end: number};

// We need an export, otherwise typescript will insist that "location" refers to "window.location"
export {};
`;
function uniqueTypeParam(i) {
  return `__T_${i}`;
}
class TypeExtractor {
  constructor(grammar, options) {
    /**
     * Rename all grammar rules and references
     * as specified in the name map.
     */
    __privateAdd(this, _renameGrammarRules);
    /**
     * Create a map of Peggy grammar rules to their type names.
     * Depending on the options, this will convert names to CamelCase.
     */
    __privateAdd(this, _initNameMap);
    /**
     * Add the global initializer and the initializer code to
     * the header (the parts between `{...}` at the start of a grammar)
     */
    __privateAdd(this, _initSourceHeader);
    __publicField(this, "grammar");
    __publicField(this, "sourceHeader", SOURCE_HEADER);
    __publicField(this, "project", new Project({
      compilerOptions: {
        allowJs: true,
        target: ScriptTarget.ESNext,
        strict: true
      },
      skipAddingFilesFromTsConfig: true,
      skipFileDependencyResolution: true,
      useInMemoryFileSystem: true
    }));
    __publicField(this, "nameMap", /* @__PURE__ */ new Map());
    __publicField(this, "typeCache", /* @__PURE__ */ new Map());
    __publicField(this, "options", {
      removeReadonlyKeyword: true,
      camelCaseTypeNames: true
    });
    __publicField(this, "formatter", (str) => {
      try {
        return prettier.format(str, {
          parser: "typescript",
          plugins: [prettierPluginTypescript]
        });
      } catch (e) {
        console.warn("Encountered error when formatting types with Prettier", e);
      }
      return str;
    });
    if (typeof grammar === "string") {
      grammar = peggy.generate(grammar, { output: "ast" });
    }
    this.grammar = grammar;
    Object.assign(this.options, options || {});
    __privateMethod(this, _initSourceHeader, initSourceHeader_fn).call(this);
    __privateMethod(this, _initNameMap, initNameMap_fn).call(this);
    __privateMethod(this, _renameGrammarRules, renameGrammarRules_fn).call(this);
  }
  /**
   * Create typescript source code for the types in the grammar.
   *
   * @param typeOverrides - An object whose keys are rule names and values are types. These will override any computed type. They can be full typescript expressions (e.g. `Foo | Bar`).
   */
  getTypes(options) {
    let { typeOverrides } = options || {};
    const file = this.project.createSourceFile("__types__.ts", TYPES_HEADER, { overwrite: true });
    const ensureCached = (rule) => {
      let typeCacheString = `type ${rule.name} = ${rule.type}`;
      try {
        typeCacheString = this.formatter(typeCacheString).trim();
        if (typeCacheString.endsWith(";")) {
          typeCacheString = typeCacheString.slice(0, typeCacheString.length - 1);
        }
      } catch {
      }
      this.typeCache.set(rule.name, typeCacheString);
      this.typeCache.set(this.nameMap.get(rule.name) || "UNKNOWN", typeCacheString);
      return rule;
    };
    this.grammar.rules.map((rule) => {
      if (typeOverrides == null ? void 0 : typeOverrides[rule.name]) {
        return ensureCached({
          name: rule.name,
          type: typeOverrides[rule.name]
        });
      }
      let type = this.getTypeForExpression(rule.expression);
      if (this.options.removeReadonlyKeyword) {
        type = type.replace(/readonly\s/g, "");
      }
      return ensureCached({
        name: rule.name,
        type
      });
    }).map((dec) => {
      return file.addTypeAlias(dec).setIsExported(true);
    });
    pruneCircularReferences(file);
    return this.formatter(file.getFullText());
  }
  /**
   * Returns the best-guess type for an Expression node in the grammar.
   *
   * For example, a rule with definition `Foo = [a-z]` would be type `string`.
   * A rule with definition `Foo = Bar / Baz` would be type `Bar | Baz`.
   */
  getTypeForExpression(expr) {
    const type = expr.type;
    switch (type) {
      case "named":
        return this.getTypeForExpression(expr.expression);
      case "any":
      case "class":
      case "text":
        return "string";
      case "literal":
        if (expr.ignoreCase) {
          return "string";
        }
        return escapedString(expr.value);
      case "rule_ref":
        return expr.name;
      case "optional":
        return `(${this.getTypeForExpression(expr.expression)}) | null`;
      case "zero_or_more":
      case "one_or_more":
      case "repeated":
        return `(${this.getTypeForExpression(expr.expression)})[]`;
      case "choice":
        return formatUnionType(expr.alternatives.map((e) => `(${this.getTypeForExpression(e)})`));
      case "sequence": {
        const pickedElement = expr.elements.find((e) => e.type === "labeled" && e.pick);
        if (pickedElement) {
          return this.getTypeForExpression(pickedElement);
        }
        return `[ ${expr.elements.map((e) => this.getTypeForExpression(e)).join(" , ")} ]`;
      }
      case "simple_and":
      case "simple_not":
      case "semantic_and":
      case "semantic_not":
        return "undefined";
      case "group":
        return this.getTypeForExpression(expr.expression);
      case "labeled":
        return this.getTypeForExpression(expr.expression);
      case "action":
        return this._getTypeForAction(expr);
    }
    const unknownType = type;
    console.warn("Peggy node of type", unknownType, "is currently not processed");
    return "unknown";
  }
  _getTypeForAction(action) {
    const file = this.project.createSourceFile("__temp__.ts", this.sourceHeader, {
      overwrite: true
    });
    const expressions = action.expression.type === "sequence" ? action.expression.elements : [action.expression];
    const labelNames = expressions.flatMap((e) => {
      if (e.type === "labeled") {
        return [
          {
            name: e.label ?? "UNKNOWN_LABEL",
            type: this.getTypeForExpression(e.expression)
          }
        ];
      }
      return [];
    });
    const func = file.addFunction({
      name: "tmpFunc",
      statements: action.code,
      parameters: labelNames.map((l, i) => ({
        name: l.name,
        type: uniqueTypeParam(i)
      })),
      typeParameters: labelNames.map((l, i) => ({
        name: uniqueTypeParam(i),
        constraint: l.type
      }))
    });
    func.getBodyOrThrow().getChildrenOfKind(ts.SyntaxKind.ReturnStatement).forEach((r) => {
      const parent = getEnclosingFunction(r);
      if (!parent || parent.getStart() !== func.getStart()) {
        return;
      }
      const returnExpression = r.getExpression();
      if (isLiteral(returnExpression)) {
        wrapNodeInAsConstDeclaration(returnExpression);
      }
    });
    const returnType = func.getReturnType();
    const finalType = file.addTypeAlias({
      name: "tmpType",
      typeParameters: labelNames.map((l, i) => ({
        name: uniqueTypeParam(i)
      })),
      type: returnType.getText(func, ts.TypeFormatFlags.NoTruncation)
    });
    let finalTypeNode = finalType.getTypeNodeOrThrow();
    const paramsToType = new Map(labelNames.map((l, i) => [uniqueTypeParam(i), l.type]));
    if (finalTypeNode.isKind(ts.SyntaxKind.TypeReference)) {
      const name = finalTypeNode.getTypeName();
      const identifier = name.getText();
      if (paramsToType.has(identifier)) {
        finalType.setType(paramsToType.get(identifier) || `ERROR`);
      }
    } else {
      finalTypeNode.forEachDescendant((c) => {
        if (c.isKind(ts.SyntaxKind.TypeReference)) {
          const name = c.getTypeName();
          const identifier = name.getText();
          if (paramsToType.has(identifier)) {
            c.replaceWithText(`(${paramsToType.get(identifier)})` || `ERROR`);
          }
        }
      });
    }
    finalTypeNode = finalType.getTypeNodeOrThrow();
    return finalTypeNode.getText();
  }
}
_renameGrammarRules = new WeakSet();
renameGrammarRules_fn = function() {
  const nameMap = this.nameMap;
  function rename(node) {
    const type = node.type;
    switch (type) {
      case "named":
        rename(node.expression);
        break;
      case "grammar":
        node.rules.forEach(rename);
        break;
      case "rule":
        node.name = nameMap.get(node.name) || "RENAME_ERROR";
        rename(node.expression);
        break;
      case "rule_ref":
        node.name = nameMap.get(node.name) || "RENAME_ERROR";
        break;
      case "sequence":
        node.elements.forEach(rename);
        break;
      case "action":
        rename(node.expression);
        break;
      case "choice":
        node.alternatives.forEach(rename);
        break;
      case "group":
      case "labeled":
      case "one_or_more":
      case "optional":
      case "simple_and":
      case "simple_not":
      case "zero_or_more":
      case "text":
        rename(node.expression);
        break;
      case "any":
      case "semantic_and":
      case "semantic_not":
      case "literal":
      case "class":
        break;
      case "repeated":
        rename(node.expression);
        if (node.delimiter) {
          rename(node.delimiter);
        }
        break;
      default: {
        console.warn("Did not handle renaming of Peggy node with type", type);
      }
    }
  }
  rename(this.grammar);
};
_initNameMap = new WeakSet();
initNameMap_fn = function() {
  const newNames = this.options.camelCaseTypeNames ? this.grammar.rules.map((rule) => [rule.name, snakeToCamel(rule.name)]) : this.grammar.rules.map((rule) => [rule.name, rule.name]);
  const existingNames = new Map(newNames.map((n) => [n[1], n[0]]));
  for (let i = 0; i < newNames.length; i++) {
    const [oldName, newName] = newNames[i];
    if (isKeyword(newName)) {
      const nonClashingName = getUniqueName(newName, existingNames, true);
      existingNames.set(nonClashingName, newName);
      newNames[i] = [oldName, nonClashingName];
    }
  }
  newNames.filter(([a, b]) => a === b).forEach(([a, b]) => this.nameMap.set(a, b));
  for (const [oldName, newName] of newNames) {
    if (this.nameMap.get(oldName) === newName) {
      continue;
    }
    const nameProposal = getUniqueName(newName, this.nameMap);
    this.nameMap.set(oldName, nameProposal);
    this.nameMap.set(nameProposal, oldName);
  }
};
_initSourceHeader = new WeakSet();
initSourceHeader_fn = function() {
  var _a, _b;
  if ((_a = this.grammar.topLevelInitializer) == null ? void 0 : _a.code) {
    this.sourceHeader += "\n;// Global Initializer\n" + this.grammar.topLevelInitializer.code + "\n;\n";
  }
  if ((_b = this.grammar.initializer) == null ? void 0 : _b.code) {
    this.sourceHeader += "\n;// Initializer\n" + this.grammar.initializer.code + "\n;\n";
  }
};
const COMMON_TYPES_STR = `
export interface FilePosition {
  offset: number;
  line: number;
  column: number;
}

export interface FileRange {
  start: FilePosition;
  end: FilePosition;
  source: string;
}

export interface LiteralExpectation {
  type: "literal";
  text: string;
  ignoreCase: boolean;
}

export interface ClassParts extends Array<string | ClassParts> {}

export interface ClassExpectation {
  type: "class";
  parts: ClassParts;
  inverted: boolean;
  ignoreCase: boolean;
}

export interface AnyExpectation {
  type: "any";
}

export interface EndExpectation {
  type: "end";
}

export interface OtherExpectation {
  type: "other";
  description: string;
}

export type Expectation = LiteralExpectation | ClassExpectation | AnyExpectation | EndExpectation | OtherExpectation;

declare class _PeggySyntaxError extends Error {
  public static buildMessage(expected: Expectation[], found: string | null): string;
  public message: string;
  public expected: Expectation[];
  public found: string | null;
  public location: FileRange;
  public name: string;
  constructor(message: string, expected: Expectation[], found: string | null, location: FileRange);
  format(sources: {
    source?: any;
    text: string;
  }[]): string;
}

export interface TraceEvent {
    type: string;
    rule: string;
    result?: any;
    location: FileRange;
  }

declare class _DefaultTracer {
  private indentLevel: number;
  public trace(event: TraceEvent): void;
}

`;
const generateParser = (ast, options, _session) => {
  var _a, _b, _c, _d, _e, _f, _g;
  const code = ast.code;
  if (!code) {
    throw new Error(
      `tspegjs requires peggy to generate source Javascript source code before continuing, but something went wrong and no generated source code was found`
    );
  }
  let computedTypes = "";
  const typeExtractor = new TypeExtractor(ast, {
    camelCaseTypeNames: !((_a = options.tspegjs) == null ? void 0 : _a.doNotCamelCaseTypes)
  });
  if (!((_b = options.tspegjs) == null ? void 0 : _b.skipTypeComputation) || ((_c = options.tspegjs) == null ? void 0 : _c.onlyGenerateGrammarTypes)) {
    computedTypes = typeExtractor.getTypes({
      typeOverrides: options.returnTypes
    });
  }
  if ((_d = options.tspegjs) == null ? void 0 : _d.onlyGenerateGrammarTypes) {
    code.children.length = 0;
    code.add(options.tspegjs.customHeader || "");
    if (!(options.tspegjs.customHeader || "").endsWith("\n")) {
      code.add("\n");
    }
    code.add(computedTypes);
    return;
  }
  annotateWithTsIgnore(code);
  const SourceNode = code.constructor;
  const rootNode = new SourceNode();
  const destructuredParser = new SourceNode();
  rootNode.add(destructuredParser);
  destructuredParser.add(code);
  ast.code = rootNode;
  if (options.dependencies) {
    const dependencyImports = Object.entries(options.dependencies).map(
      ([varName, importPath]) => `import ${varName} from ${escapedString(importPath)};`
    );
    rootNode.prepend("\n" + dependencyImports.join("\n") + "\n");
  }
  if ((_e = options.tspegjs) == null ? void 0 : _e.customHeader) {
    rootNode.prepend(options.tspegjs.customHeader + "\n\n");
  }
  rootNode.prepend("/* eslint-disable */\n\n");
  destructuredParser.prepend(
    `const peggyParser: {parse: any, SyntaxError: any, DefaultTracer?: any} = `
  );
  rootNode.add(COMMON_TYPES_STR);
  const errorName = ((_f = options.tspegjs) == null ? void 0 : _f.errorName) || "PeggySyntaxError";
  if (errorName !== JSON.stringify(errorName).slice(1, errorName.length + 1)) {
    throw new Error(
      `The errorName ${JSON.stringify(errorName)} is not a valid Javascript identifier`
    );
  }
  rootNode.add(`peggyParser.SyntaxError.prototype.name = ${JSON.stringify(errorName)};
`);
  const defaultStartRule = (options.allowedStartRules || [])[0] || ((_g = ast.rules[0]) == null ? void 0 : _g.name);
  if (!defaultStartRule) {
    throw new Error(`Something wen't wrong...Could not determine the default start rule.`);
  }
  let startRuleType = "string";
  if (options.allowedStartRules) {
    startRuleType = options.allowedStartRules.map((x) => JSON.stringify(x)).join(" | ");
  }
  const parseFunctionType = computedTypes ? createParseFunctionType(options.allowedStartRules || [], typeExtractor) : `export type ParseFunction = (input: string, options?: ParseOptions) => any`;
  rootNode.add(`
export interface ParseOptions {
  filename?: string;
  startRule?: ${startRuleType};
  tracer?: any;
  [key: string]: any;
}
${parseFunctionType}
export const parse: ParseFunction = peggyParser.parse;
`);
  rootNode.add([
    `
export const ${errorName} = peggyParser.SyntaxError as typeof _PeggySyntaxError;
`,
    `
export type ${errorName} = _PeggySyntaxError;
`
  ]);
  if (options.trace) {
    rootNode.add([
      `
export const DefaultTracer = peggyParser.DefaultTracer as typeof _DefaultTracer;
`,
      `
export type DefaultTracer = _DefaultTracer;
`
    ]);
  }
  if (computedTypes) {
    rootNode.add("\n");
    rootNode.add(computedTypes);
  }
};
function annotateWithTsIgnore(code) {
  if (!code.children || code.children.length === 0) {
    return;
  }
  const children = [...code.children];
  code.children.length = 0;
  for (const child of children) {
    if (typeof child === "string") {
      if (tsIgnoreShouldApply(child)) {
        code.children.push("// @ts-ignore\n");
      }
      code.children.push(child);
    } else if (typeof child === "object" && child.children) {
      annotateWithTsIgnore(child);
      code.children.push(child);
    }
  }
}
function tsIgnoreShouldApply(line) {
  line = line.trim();
  if (!line || line.startsWith("//")) {
    return false;
  }
  if (!line.match(/[a-zA-Z]/)) {
    return false;
  }
  return true;
}
function createParseFunctionType(allowedStartRules, typeExtractor) {
  const defaultStartRule = typeExtractor.nameMap.get(allowedStartRules[0]);
  if (!defaultStartRule) {
    throw new Error("Cannot determine the default starting rule.");
  }
  let startRuleChain = allowedStartRules.map(
    (rule) => `StartRule extends ${JSON.stringify(rule)} ? ${typeExtractor.nameMap.get(rule)} :`
  ).join("\n    ") + ` ${defaultStartRule}`;
  return `export type ParseFunction = <Options extends ParseOptions>(
    input: string,
    options?: Options
  ) => Options extends { startRule: infer StartRule } ?
    ${startRuleChain}
    : ${defaultStartRule};`;
}
const tspegjs = {
  use(config, options) {
    options.format = "bare";
    config.passes.generate.push(generateParser);
    if (!options.tspegjs) {
      options.tspegjs = {};
    }
    if (options.tspegjs.customHeader === void 0) {
      options.tspegjs.customHeader = null;
    }
  }
};
export {
  tspegjs as default
};
